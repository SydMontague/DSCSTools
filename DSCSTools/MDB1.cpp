#include "MDB1.h"
#include <ciso646>
#include <vector>
#include <map>
#include <future>
#include <string>
#include <fstream>
#include <iostream>
#include <deque>
#include "../libs/doboz/Compressor.h"
#include "../libs/doboz/Decompressor.h"

#define MDB1_MAGIC_VALUE 0x3142444D
const uint8_t CRYPT_KEY_1[997] = { 0xD3, 0x53, 0xD2, 0x85, 0xDC, 0x87, 0x77, 0xA7, 0x16, 0xFA, 0x8D, 0x45, 0x9D, 0x14, 0x60, 0x3B, 0x9B, 0x7B, 0xDA, 0xED, 0x25, 0xFD, 0xF5, 0x8D, 0x44, 0xD0, 0xEB, 0x8B, 0xAB, 0x4B, 0x6A, 0x3E, 0x01, 0x28, 0x63, 0xA3, 0xE3, 0x23, 0x63, 0xA3, 0xE2, 0x55, 0x6D, 0xA5, 0x7C, 0xA8, 0xE4, 0xF0, 0x8B, 0xAA, 0x7D, 0x74, 0x40, 0x9C, 0x47, 0x36, 0x9A, 0xAE, 0xB1, 0x19, 0x60, 0x3B, 0x9A, 0xAD, 0xE4, 0xEF, 0xBE, 0x82, 0x76, 0xDA, 0xED, 0x25, 0xFD, 0xF5, 0x8D, 0x45, 0x9C, 0x47, 0x37, 0x67, 0xD6, 0xB9, 0x81, 0xA8, 0xE3, 0x22, 0x96, 0x79, 0x40, 0x9C, 0x48, 0x04, 0x90, 0xAB, 0x4B, 0x6B, 0x0A, 0x5E, 0xA1, 0x48, 0x03, 0xC3, 0x83, 0x42, 0x35, 0xCD, 0x85, 0xDD, 0x55, 0x6C, 0xD7, 0x87, 0x76, 0xD9, 0x20, 0xFC, 0x28, 0x63, 0xA2, 0x15, 0x2D, 0x64, 0x6F, 0x3E, 0x02, 0xF6, 0x5A, 0x6D, 0xA5, 0x7D, 0x74, 0x3F, 0xCE, 0x51, 0x39, 0x00, 0x5C, 0x08, 0xC3, 0x82, 0x75, 0x0C, 0xF8, 0xF3, 0xF2, 0x26, 0xCA, 0x1E, 0x62, 0xD5, 0xED, 0x24, 0x30, 0xCC, 0xB8, 0xB3, 0xB3, 0xB2, 0xE6, 0x89, 0x11, 0xF9, 0xC0, 0x1B, 0xFA, 0x8E, 0x12, 0xC6, 0xE9, 0xF1, 0x58, 0xD4, 0x20, 0xFB, 0x5B, 0x3B, 0x9A, 0xAD, 0xE4, 0xF0, 0x8B, 0xAA, 0x7D, 0x74, 0x40, 0x9C, 0x47, 0x36, 0x9A, 0xAD, 0xE4, 0xF0, 0x8C, 0x77, 0xA7, 0x16, 0xFA, 0x8D, 0x45, 0x9C, 0x47, 0x36, 0x99, 0xE0, 0xBB, 0x1B, 0xFB, 0x5B, 0x3B, 0x9B, 0x7A, 0x0E, 0x91, 0x78, 0x73, 0x73, 0x72, 0xA5, 0x7D, 0x75, 0x0C, 0xF7, 0x26, 0xC9, 0x51, 0x38, 0x34, 0x00, 0x5C, 0x08, 0xC4, 0x50, 0x6C, 0xD7, 0x86, 0xAA, 0x7D, 0x75, 0x0C, 0xF7, 0x26, 0xC9, 0x50, 0x6B, 0x0B, 0x2A, 0xFE, 0xC2, 0xB6, 0x19, 0x60, 0x3C, 0x68, 0xA4, 0xB0, 0x4C, 0x38, 0x33, 0x32, 0x65, 0x3D, 0x34, 0x00, 0x5C, 0x07, 0xF6, 0x59, 0xA0, 0x7C, 0xA7, 0x16, 0xF9, 0xC1, 0xE8, 0x24, 0x2F, 0xFF, 0x8E, 0x12, 0xC6, 0xE9, 0xF0, 0x8C, 0x78, 0x74, 0x40, 0x9B, 0x7A, 0x0E, 0x91, 0x79, 0x41, 0x69, 0x71, 0xD9, 0x20, 0xFB, 0x5B, 0x3B, 0x9A, 0xAE, 0xB2, 0xE6, 0x8A, 0xDE, 0x22, 0x95, 0xAC, 0x18, 0x93, 0x12, 0xC5, 0x1D, 0x95, 0xAC, 0x18, 0x93, 0x13, 0x93, 0x12, 0xC6, 0xEA, 0xBD, 0xB5, 0x4C, 0x38, 0x34, 0x00, 0x5B, 0x3B, 0x9A, 0xAD, 0xE5, 0xBD, 0xB5, 0x4C, 0x38, 0x34, 0xFF, 0x8E, 0x11, 0xF8, 0xF4, 0xC0, 0x1B, 0xFB, 0x5B, 0x3B, 0x9A, 0xAE, 0xB2, 0xE5, 0xBD, 0xB5, 0x4D, 0x05, 0x5D, 0xD5, 0xED, 0x24, 0x30, 0xCC, 0xB8, 0xB4, 0x7F, 0x0F, 0x5E, 0xA2, 0x15, 0x2D, 0x64, 0x6F, 0x3E, 0x02, 0xF6, 0x59, 0xA1, 0x48, 0x03, 0xC2, 0xB6, 0x1A, 0x2E, 0x31, 0x98, 0x13, 0x93, 0x12, 0xC5, 0x1D, 0x95, 0xAD, 0xE4, 0xF0, 0x8C, 0x77, 0xA7, 0x16, 0xF9, 0xC1, 0xE9, 0xF1, 0x58, 0xD4, 0x20, 0xFB, 0x5B, 0x3A, 0xCD, 0x84, 0x10, 0x2C, 0x98, 0x14, 0x5F, 0x6E, 0x72, 0xA5, 0x7C, 0xA8, 0xE4, 0xEF, 0xBE, 0x81, 0xA9, 0xB0, 0x4B, 0x6B, 0x0A, 0x5D, 0xD4, 0x20, 0xFC, 0x27, 0x97, 0x47, 0x37, 0x66, 0x09, 0x90, 0xAB, 0x4A, 0x9E, 0xE2, 0x55, 0x6C, 0xD8, 0x54, 0x9F, 0xAE, 0xB2, 0xE6, 0x89, 0x11, 0xF9, 0xC0, 0x1C, 0xC7, 0xB6, 0x1A, 0x2E, 0x32, 0x66, 0x09, 0x91, 0x79, 0x41, 0x68, 0xA4, 0xB0, 0x4B, 0x6A, 0x3E, 0x02, 0xF6, 0x59, 0xA1, 0x48, 0x04, 0x90, 0xAB, 0x4B, 0x6A, 0x3E, 0x01, 0x28, 0x63, 0xA3, 0xE2, 0x56, 0x39, 0x01, 0x28, 0x63, 0xA2, 0x16, 0xF9, 0xC0, 0x1B, 0xFA, 0x8E, 0x11, 0xF9, 0xC1, 0xE9, 0xF1, 0x59, 0xA1, 0x48, 0x03, 0xC3, 0x82, 0x76, 0xD9, 0x20, 0xFC, 0x27, 0x96, 0x79, 0x40, 0x9B, 0x7B, 0xDA, 0xEE, 0xF1, 0x59, 0xA0, 0x7C, 0xA7, 0x17, 0xC7, 0xB7, 0xE6, 0x89, 0x11, 0xF9, 0xC1, 0xE9, 0xF1, 0x59, 0xA0, 0x7C, 0xA7, 0x16, 0xFA, 0x8D, 0x44, 0xCF, 0x1E, 0x62, 0xD5, 0xED, 0x25, 0xFD, 0xF4, 0xBF, 0x4E, 0xD1, 0xB8, 0xB3, 0xB2, 0xE5, 0xBC, 0xE7, 0x57, 0x06, 0x2A, 0xFE, 0xC2, 0xB5, 0x4D, 0x04, 0x8F, 0xDE, 0x22, 0x96, 0x79, 0x40, 0x9B, 0x7B, 0xDA, 0xED, 0x25, 0xFC, 0x28, 0x64, 0x70, 0x0C, 0xF7, 0x27, 0x97, 0x46, 0x6A, 0x3D, 0x35, 0xCC, 0xB7, 0xE7, 0x56, 0x3A, 0xCD, 0x84, 0x0F, 0x5E, 0xA1, 0x48, 0x04, 0x90, 0xAC, 0x18, 0x94, 0xDF, 0xEE, 0xF1, 0x59, 0xA1, 0x49, 0xD1, 0xB9, 0x80, 0xDC, 0x88, 0x43, 0x03, 0xC3, 0x82, 0x76, 0xD9, 0x20, 0xFB, 0x5B, 0x3A, 0xCE, 0x52, 0x06, 0x29, 0x31, 0x98, 0x14, 0x60, 0x3C, 0x67, 0xD7, 0x86, 0xAA, 0x7E, 0x42, 0x35, 0xCD, 0x85, 0xDD, 0x55, 0x6D, 0xA5, 0x7D, 0x75, 0x0D, 0xC5, 0x1D, 0x94, 0xE0, 0xBB, 0x1A, 0x2D, 0x64, 0x6F, 0x3E, 0x01, 0x29, 0x30, 0xCB, 0xEA, 0xBE, 0x81, 0xA9, 0xB0, 0x4C, 0x38, 0x34, 0xFF, 0x8F, 0xDE, 0x22, 0x95, 0xAD, 0xE5, 0xBD, 0xB5, 0x4C, 0x37, 0x66, 0x09, 0x91, 0x79, 0x40, 0x9C, 0x47, 0x37, 0x67, 0xD7, 0x86, 0xAA, 0x7D, 0x74, 0x40, 0x9C, 0x47, 0x37, 0x66, 0x09, 0x90, 0xAB, 0x4B, 0x6B, 0x0A, 0x5D, 0xD5, 0xEC, 0x58, 0xD3, 0x53, 0xD3, 0x53, 0xD3, 0x52, 0x06, 0x29, 0x30, 0xCC, 0xB8, 0xB4, 0x7F, 0x0F, 0x5F, 0x6F, 0x3E, 0x02, 0xF5, 0x8D, 0x45, 0x9D, 0x14, 0x5F, 0x6F, 0x3E, 0x01, 0x29, 0x31, 0x98, 0x13, 0x93, 0x13, 0x92, 0x45, 0x9D, 0x14, 0x5F, 0x6E, 0x71, 0xD8, 0x54, 0xA0, 0x7B, 0xDB, 0xBA, 0x4D, 0x05, 0x5C, 0x08, 0xC3, 0x82, 0x75, 0x0D, 0xC4, 0x4F, 0x9F, 0xAE, 0xB1, 0x19, 0x60, 0x3C, 0x68, 0xA4, 0xAF, 0x7F, 0x0E, 0x92, 0x45, 0x9D, 0x14, 0x60, 0x3C, 0x67, 0xD7, 0x86, 0xA9, 0xB0, 0x4C, 0x37, 0x67, 0xD6, 0xBA, 0x4D, 0x04, 0x90, 0xAB, 0x4A, 0x9D, 0x14, 0x5F, 0x6E, 0x72, 0xA6, 0x49, 0xD1, 0xB9, 0x80, 0xDB, 0xBB, 0x1B, 0xFA, 0x8D, 0x44, 0xCF, 0x1E, 0x62, 0xD6, 0xB9, 0x80, 0xDC, 0x87, 0x77, 0xA6, 0x49, 0xD1, 0xB9, 0x80, 0xDB, 0xBB, 0x1B, 0xFA, 0x8D, 0x44, 0xD0, 0xEB, 0x8A, 0xDE, 0x21, 0xC8, 0x84, 0x0F, 0x5E, 0xA1, 0x49, 0xD1, 0xB8, 0xB4, 0x80, 0xDC, 0x88, 0x43, 0x03, 0xC3, 0x83, 0x42, 0x35, 0xCD, 0x84, 0x0F, 0x5E, 0xA1, 0x48, 0x04, 0x8F, 0xDF, 0xEE, 0xF1, 0x59, 0xA0, 0x7C, 0xA7, 0x17, 0xC7, 0xB6, 0x19, 0x61, 0x08, 0xC4, 0x4F, 0x9F, 0xAE, 0xB1, 0x18, 0x93, 0x12, 0xC6, 0xEA, 0xBD, 0xB4, 0x80, 0xDC, 0x88, 0x44, 0xD0, 0xEB, 0x8B, 0xAB, 0x4B, 0x6B, 0x0B, 0x2A, 0xFE, 0xC2, 0xB6, 0x1A, 0x2D, 0x65, 0x3D, 0x35, 0xCC, 0xB8, 0xB4, 0x80, 0xDC, 0x88, 0x43, 0x03, 0xC2, 0xB5, 0x4D, 0x04, 0x8F, 0xDF, 0xEF, 0xBE, 0x81, 0xA8, 0xE3, 0x23, 0x63, 0xA2, 0x16, 0xF9, 0xC0, 0x1B, 0xFA, 0x8E, 0x11, 0xF9, 0xC1, 0xE9, 0xF0, 0x8B, 0xAA, 0x7E, 0x42, 0x35, 0xCD, 0x84, 0x10, 0x2C, 0x97, 0x46, 0x69, 0x70, 0x0C, 0xF7, 0x27, 0x97, 0x47, 0x37, 0x66, 0x0A, 0x5E, 0xA1, 0x49, 0xD0, 0xEC, 0x58, 0xD4, 0x20, 0xFC, 0x28, 0x64, 0x6F, 0x3E, 0x01, 0x28, 0x63, 0xA2, 0x15, 0x2C, 0x98, 0x14, 0x60, 0x3B, 0x9B };
const uint8_t CRYPT_KEY_2[991] = { 0x92, 0x85, 0x1D, 0xD4, 0x60, 0x7B, 0x1B, 0x3B, 0xDB, 0xFA, 0xCE, 0x92, 0x85, 0x1D, 0xD5, 0x2D, 0xA4, 0xF0, 0xCB, 0x2A, 0x3D, 0x74, 0x80, 0x1B, 0x3B, 0xDB, 0xFA, 0xCD, 0xC5, 0x5C, 0x47, 0x77, 0xE7, 0x97, 0x87, 0xB6, 0x5A, 0xAD, 0x24, 0x6F, 0x7E, 0x82, 0xB6, 0x5A, 0xAD, 0x25, 0x3D, 0x75, 0x4C, 0x78, 0xB4, 0xC0, 0x5B, 0x7B, 0x1A, 0x6D, 0xE4, 0x2F, 0x3E, 0x42, 0x76, 0x1A, 0x6D, 0xE4, 0x30, 0x0C, 0x37, 0xA7, 0x57, 0x47, 0x76, 0x1A, 0x6E, 0xB1, 0x59, 0xE1, 0xC9, 0x91, 0xB9, 0xC1, 0x28, 0xA3, 0x22, 0xD5, 0x2C, 0xD7, 0xC7, 0xF6, 0x99, 0x21, 0x08, 0x03, 0x02, 0x35, 0x0C, 0x38, 0x73, 0xB3, 0xF2, 0x66, 0x49, 0x10, 0x6C, 0x17, 0x06, 0x6A, 0x7E, 0x82, 0xB5, 0x8C, 0xB8, 0xF4, 0x00, 0x9C, 0x87, 0xB6, 0x59, 0xE1, 0xC9, 0x90, 0xEC, 0x97, 0x87, 0xB7, 0x26, 0x0A, 0x9E, 0x21, 0x09, 0xD1, 0xF9, 0x01, 0x68, 0xE4, 0x2F, 0x3F, 0x0F, 0x9F, 0xEF, 0xFF, 0xCE, 0x92, 0x86, 0xE9, 0x31, 0xD8, 0x94, 0x20, 0x3B, 0xDB, 0xFA, 0xCE, 0x92, 0x85, 0x1C, 0x08, 0x03, 0x02, 0x36, 0xD9, 0x60, 0x7C, 0xE8, 0x63, 0xE3, 0x62, 0x15, 0x6D, 0xE5, 0xFD, 0x34, 0x3F, 0x0F, 0x9F, 0xEF, 0xFE, 0x02, 0x36, 0xDA, 0x2D, 0xA4, 0xEF, 0xFE, 0x01, 0x69, 0xB1, 0x59, 0xE0, 0xFB, 0x9B, 0xBA, 0x8D, 0x85, 0x1D, 0xD4, 0x60, 0x7B, 0x1B, 0x3B, 0xDB, 0xFB, 0x9A, 0xEE, 0x32, 0xA5, 0xBC, 0x28, 0xA3, 0x23, 0xA3, 0x23, 0xA3, 0x23, 0xA3, 0x22, 0xD6, 0xFA, 0xCE, 0x92, 0x86, 0xE9, 0x30, 0x0C, 0x38, 0x74, 0x7F, 0x4F, 0xDF, 0x2F, 0x3E, 0x41, 0xA8, 0x23, 0xA3, 0x23, 0xA3, 0x22, 0xD5, 0x2D, 0xA4, 0xF0, 0xCC, 0xF7, 0x67, 0x16, 0x39, 0x40, 0xDB, 0xFB, 0x9B, 0xBA, 0x8D, 0x84, 0x4F, 0xDE, 0x62, 0x16, 0x39, 0x40, 0xDC, 0xC7, 0xF6, 0x99, 0x21, 0x08, 0x04, 0xD0, 0x2C, 0xD8, 0x94, 0x1F, 0x6F, 0x7E, 0x82, 0xB5, 0x8D, 0x85, 0x1C, 0x08, 0x04, 0xD0, 0x2C, 0xD8, 0x93, 0x53, 0x12, 0x05, 0x9C, 0x88, 0x84, 0x4F, 0xDE, 0x61, 0x48, 0x44, 0x0F, 0x9E, 0x22, 0xD5, 0x2D, 0xA5, 0xBC, 0x28, 0xA4, 0xF0, 0xCB, 0x2B, 0x0A, 0x9D, 0x55, 0xAC, 0x58, 0x14, 0xA0, 0xBC, 0x28, 0xA3, 0x22, 0xD6, 0xF9, 0x00, 0x9B, 0xBA, 0x8E, 0x52, 0x45, 0xDC, 0xC7, 0xF7, 0x67, 0x17, 0x06, 0x69, 0xB1, 0x58, 0x13, 0xD2, 0xC6, 0x29, 0x71, 0x18, 0xD4, 0x5F, 0xAE, 0xF1, 0x98, 0x54, 0xE0, 0xFC, 0x68, 0xE4, 0x2F, 0x3F, 0x0E, 0xD1, 0xF9, 0x01, 0x69, 0xB1, 0x58, 0x14, 0x9F, 0xEE, 0x32, 0xA5, 0xBD, 0xF4, 0xFF, 0xCE, 0x91, 0xB9, 0xC0, 0x5B, 0x7B, 0x1B, 0x3A, 0x0D, 0x05, 0x9C, 0x87, 0xB6, 0x5A, 0xAE, 0xF2, 0x65, 0x7C, 0xE8, 0x63, 0xE3, 0x62, 0x15, 0x6C, 0x17, 0x07, 0x36, 0xD9, 0x61, 0x48, 0x43, 0x43, 0x42, 0x75, 0x4C, 0x78, 0xB3, 0xF3, 0x33, 0x72, 0xE6, 0xCA, 0x5E, 0xE1, 0xC8, 0xC3, 0xC3, 0xC3, 0xC2, 0xF6, 0x99, 0x21, 0x08, 0x04, 0xD0, 0x2C, 0xD8, 0x94, 0x1F, 0x6E, 0xB2, 0x26, 0x0A, 0x9E, 0x22, 0xD5, 0x2D, 0xA4, 0xEF, 0xFF, 0xCF, 0x5F, 0xAF, 0xBE, 0xC2, 0xF5, 0xCC, 0xF7, 0x66, 0x4A, 0xDE, 0x61, 0x49, 0x11, 0x39, 0x41, 0xA8, 0x24, 0x70, 0x4C, 0x77, 0xE7, 0x97, 0x86, 0xEA, 0xFD, 0x34, 0x40, 0xDB, 0xFA, 0xCE, 0x92, 0x86, 0xE9, 0x31, 0xD8, 0x93, 0x52, 0x46, 0xAA, 0xBD, 0xF5, 0xCD, 0xC5, 0x5D, 0x14, 0xA0, 0xBB, 0x5A, 0xAE, 0xF2, 0x65, 0x7C, 0xE7, 0x97, 0x86, 0xEA, 0xFD, 0x34, 0x3F, 0x0E, 0xD2, 0xC5, 0x5D, 0x15, 0x6D, 0xE5, 0xFD, 0x35, 0x0C, 0x37, 0xA7, 0x57, 0x47, 0x77, 0xE7, 0x97, 0x87, 0xB6, 0x59, 0xE1, 0xC8, 0xC4, 0x8F, 0x1E, 0xA2, 0x55, 0xAD, 0x24, 0x70, 0x4C, 0x77, 0xE7, 0x96, 0xB9, 0xC0, 0x5C, 0x47, 0x76, 0x1A, 0x6D, 0xE4, 0x2F, 0x3E, 0x41, 0xA9, 0xF1, 0x98, 0x53, 0x12, 0x06, 0x69, 0xB0, 0x8C, 0xB7, 0x26, 0x0A, 0x9D, 0x54, 0xDF, 0x2E, 0x72, 0xE5, 0xFD, 0x34, 0x3F, 0x0F, 0x9F, 0xEE, 0x32, 0xA5, 0xBD, 0xF4, 0xFF, 0xCF, 0x5E, 0xE1, 0xC9, 0x91, 0xB9, 0xC0, 0x5C, 0x48, 0x43, 0x42, 0x75, 0x4C, 0x78, 0xB3, 0xF2, 0x65, 0x7C, 0xE7, 0x96, 0xB9, 0xC1, 0x28, 0xA3, 0x22, 0xD5, 0x2D, 0xA5, 0xBC, 0x27, 0xD6, 0xF9, 0x01, 0x69, 0xB1, 0x58, 0x13, 0xD2, 0xC6, 0x2A, 0x3D, 0x75, 0x4D, 0x45, 0xDC, 0xC7, 0xF6, 0x99, 0x21, 0x09, 0xD0, 0x2C, 0xD7, 0xC7, 0xF7, 0x67, 0x16, 0x39, 0x41, 0xA8, 0x24, 0x6F, 0x7E, 0x82, 0xB6, 0x59, 0xE1, 0xC9, 0x90, 0xEC, 0x98, 0x53, 0x12, 0x05, 0x9C, 0x87, 0xB6, 0x5A, 0xAD, 0x25, 0x3C, 0xA8, 0x24, 0x70, 0x4C, 0x77, 0xE6, 0xCA, 0x5E, 0xE2, 0x95, 0xED, 0x64, 0xB0, 0x8B, 0xEB, 0xCB, 0x2B, 0x0A, 0x9D, 0x55, 0xAC, 0x58, 0x13, 0xD3, 0x92, 0x86, 0xEA, 0xFD, 0x34, 0x3F, 0x0E, 0xD1, 0xF8, 0x34, 0x40, 0xDC, 0xC8, 0xC4, 0x8F, 0x1E, 0xA1, 0x89, 0x50, 0xAB, 0x8A, 0x1D, 0xD5, 0x2D, 0xA4, 0xF0, 0xCB, 0x2B, 0x0A, 0x9D, 0x55, 0xAC, 0x57, 0x46, 0xA9, 0xF0, 0xCC, 0xF7, 0x67, 0x17, 0x07, 0x36, 0xDA, 0x2E, 0x71, 0x19, 0xA1, 0x88, 0x83, 0x83, 0x83, 0x82, 0xB6, 0x5A, 0xAD, 0x25, 0x3D, 0x74, 0x80, 0x1C, 0x08, 0x04, 0xCF, 0x5F, 0xAF, 0xBF, 0x8E, 0x51, 0x78, 0xB3, 0xF3, 0x32, 0xA5, 0xBD, 0xF5, 0xCD, 0xC4, 0x90, 0xEC, 0x97, 0x87, 0xB7, 0x27, 0xD7, 0xC6, 0x29, 0x70, 0x4B, 0xAB, 0x8B, 0xEB, 0xCB, 0x2A, 0x3D, 0x74, 0x7F, 0x4F, 0xDE, 0x62, 0x15, 0x6D, 0xE5, 0xFD, 0x34, 0x40, 0xDB, 0xFA, 0xCD, 0xC4, 0x90, 0xEB, 0xCA, 0x5E, 0xE1, 0xC9, 0x91, 0xB9, 0xC1, 0x28, 0xA4, 0xEF, 0xFF, 0xCE, 0x92, 0x85, 0x1D, 0xD4, 0x5F, 0xAE, 0xF2, 0x65, 0x7D, 0xB5, 0x8D, 0x84, 0x50, 0xAC, 0x57, 0x47, 0x76, 0x1A, 0x6E, 0xB1, 0x59, 0xE0, 0xFB, 0x9B, 0xBB, 0x5B, 0x7A, 0x4D, 0x45, 0xDD, 0x95, 0xED, 0x65, 0x7D, 0xB4, 0xBF, 0x8F, 0x1F, 0x6F, 0x7E, 0x81, 0xE9, 0x30, 0x0C, 0x37, 0xA6, 0x89, 0x50, 0xAC, 0x57, 0x46, 0xAA, 0xBD, 0xF5, 0xCC, 0xF7, 0x66, 0x4A, 0xDE, 0x61, 0x48, 0x44, 0x10, 0x6C, 0x18, 0xD4, 0x5F, 0xAF, 0xBE, 0xC1, 0x28, 0xA3, 0x23, 0xA2, 0x55, 0xAC, 0x58, 0x14, 0xA0, 0xBC, 0x28, 0xA4, 0xEF, 0xFF, 0xCF, 0x5E, 0xE1, 0xC8, 0xC4, 0x8F, 0x1E, 0xA1, 0x88, 0x83, 0x82, 0xB5, 0x8C, 0xB7, 0x27, 0xD6, 0xF9, 0x00, 0x9C, 0x87, 0xB6, 0x59, 0xE1, 0xC9, 0x90, 0xEC, 0x98, 0x53, 0x13, 0xD3, 0x93, 0x53, 0x12, 0x06, 0x6A, 0x7D, 0xB5, 0x8C, 0xB8, 0xF4, 0xFF, 0xCF, 0x5F, 0xAF, 0xBE, 0xC2, 0xF5, 0xCD, 0xC4, 0x8F, 0x1F, 0x6E, 0xB1, 0x59, 0xE1, 0xC8, 0xC4, 0x90, 0xEB, 0xCA, 0x5E, 0xE2, 0x95, 0xED, 0x64, 0xAF, 0xBE, 0xC1, 0x28, 0xA3, 0x23, 0xA3, 0x23, 0xA3, 0x23, 0xA2, 0x55, 0xAD, 0x25, 0x3D, 0x74, 0x7F, 0x4F, 0xDE, 0x62, 0x16, 0x39, 0x40, 0xDC, 0xC7, 0xF7, 0x67, 0x17, 0x06, 0x69, 0xB1, 0x58, 0x13, 0xD3, 0x93, 0x53, 0x13, 0xD2, 0xC5, 0x5C, 0x47, 0x77 };

// MDB1 structures
struct MDB1Header {
	uint32_t magicValue;
	uint16_t fileEntryCount;
	uint16_t fileNameCount;
	uint32_t dataEntryCount;
	uint32_t dataStart;
	uint32_t totalSize;
};

struct FileEntry {
	int16_t compareBit;
	uint16_t dataId;
	uint16_t left;
	uint16_t right;
};

struct FileNameEntry {
	char extension[4];
	char name[0x3C];

	const std::string toString() {
		std::string str(name);
		str.append(".");
		str.append(extension, 4);
		return str;
	}
};

struct DataEntry {
	uint32_t offset;
	uint32_t size;
	uint32_t compSize;
};

// helper structures
struct TreeNode {
	int16_t compareBit;
	uint16_t left = 0;
	uint16_t right = 0;
	std::string name;
};

struct CompressionResult {
	uint32_t originalSize;
	uint32_t size;
	char* data;
};

void extractMDB1(const boost::filesystem::path source, const boost::filesystem::path target) {
	if (boost::filesystem::exists(target) && !boost::filesystem::is_directory(target)) {
		std::cout << "Error: Target path exists and is not a directory, aborting." << std::endl;
		return;
	}
	if (!boost::filesystem::is_regular_file(source)) {
		std::cout << "Error: Source path doesn't point to a file, aborting." << std::endl;
		return;
	}

	doboz::Decompressor decomp;
	boost::filesystem::ifstream input(source, std::ios::in | std::ios::binary);

	char* headerBuffer = new char[0x14];
	input.read(headerBuffer, 0x14);
	MDB1Header header = *reinterpret_cast<MDB1Header*>(headerBuffer);

	if (header.magicValue != MDB1_MAGIC_VALUE) {
		std::cout << "Error: not a MDB1 file. Value: " << header.magicValue << std::endl;
		return;
	}

	FileEntry* entry1;
	FileNameEntry* entry2;
	DataEntry* entry3;
	char* entry1Buffer = new char[header.fileEntryCount * sizeof(FileEntry)];
	char* entry2Buffer = new char[header.fileNameCount * sizeof(FileNameEntry)];
	char* entry3Buffer = new char[header.dataEntryCount * sizeof(DataEntry)];
	input.read(entry1Buffer, header.fileEntryCount * sizeof(FileEntry));
	input.read(entry2Buffer, header.fileNameCount * sizeof(FileNameEntry));
	input.read(entry3Buffer, header.dataEntryCount * sizeof(DataEntry));
	entry1 = reinterpret_cast<FileEntry*>(entry1Buffer);
	entry2 = reinterpret_cast<FileNameEntry*>(entry2Buffer);
	entry3 = reinterpret_cast<DataEntry*>(entry3Buffer);

	if (header.dataStart != input.tellg())
		std::cout << "Error: stream position does not match header value! Current: " << input.tellg() << " Expected: " << header.dataStart << std::endl;

	for (int i = 0; i < header.fileEntryCount; i++) {
		FileEntry e1 = entry1[i];
		FileNameEntry name = entry2[i];

		if (e1.compareBit == 0xFFFF || e1.dataId == 0xFFFF)
			continue;

		DataEntry data = entry3[e1.dataId];

		boost::filesystem::path path(target / name.toString());
		boost::filesystem::create_directories(path.parent_path());
		boost::filesystem::ofstream output(path, std::ios::out | std::ios::binary);

		char* outputArr = new char[data.size];
		input.seekg(data.offset + header.dataStart);

		if (data.compSize == data.size)
			input.read(outputArr, data.size);
		else {
			char* dataArr = new char[data.compSize];
			input.read(dataArr, data.compSize);
			doboz::Result result = decomp.decompress(dataArr, data.compSize, outputArr, data.size);
			delete dataArr;

			if (result != doboz::RESULT_OK)
				std::cout << "Error while decompressing. doboz error code: " << result << std::endl;
		}

		output.write(outputArr, data.size);

		if (!output.good())
			std::cout << "Error: something went wrong while writing " << path << std::endl;

		output.close();
		delete outputArr;
	}

	if (!input.good())
		std::cout << "Error: something went wrong while reading " << source << std::endl;

	// cleanup
	input.close();
	delete headerBuffer;
	delete entry1Buffer;
	delete entry2Buffer;
	delete entry3Buffer;
}

TreeNode findFirstBitMismatch(const int16_t first, const std::vector<std::string>& nodeless, const std::vector<std::string>& withNode) {
	if (withNode.size() == 0)
		return { first, 0, 0, nodeless[0] };

	for (int16_t i = first; i < 512; i++) {
		bool set = false;
		bool unset = false;

		for (auto file : withNode) {
			if ((file[i >> 3] >> (i & 7)) & 1)
				set = true;
			else
				unset = true;

			if (set && unset)
				return { i, 0, 0, nodeless[0] };
		}

		auto itr = std::find_if(nodeless.begin(), nodeless.end(), [set, unset, i](const std::string &file) {
			bool val = (file[i >> 3] >> (i & 7)) & 1;
			return val && unset || !val && set;
		});

		if (itr != nodeless.end())
			return { i, 0, 0, *itr };
	}

	return { -1, 0xFFFF, 0, "" };
}

bool isAccessible(const std::vector<TreeNode> nodes, const std::string path) {
	TreeNode currentNode = nodes[1];

	while (true) {
		bool isSet = ((path[currentNode.compareBit >> 3]) >> (currentNode.compareBit & 7)) & 1;
		TreeNode nextNode = nodes[isSet ? currentNode.right : currentNode.left];

		if (nextNode.compareBit <= currentNode.compareBit)
			return nextNode.name == path;

		currentNode = nextNode;
	};

	return false;
}

std::vector<TreeNode> generateTree(const boost::filesystem::path path) {
	std::vector<std::string> fileNames;

	boost::filesystem::recursive_directory_iterator itr(path);

	// TODO quite slow?
	for (auto i : itr) {
		if (boost::filesystem::is_regular_file(i)) {
			std::string ext = i.path().extension().string().substr(1, 5);

			if (ext == "pvr")
				ext = "img ";

			if (ext.length() == 3)
				ext = ext.append(" ");

			// strncpy weirdness intended
			char name[0x40];
			strncpy(name, ext.c_str(), 4);
			strncpy(name + 4, boost::filesystem::relative(i.path(), path).replace_extension("").string().c_str(), 0x3C);

			fileNames.push_back(std::string(name));
		}
	}

	struct QueueEntry {
		uint16_t parentNode;
		int16_t val1;
		std::vector<std::string> list;
		std::vector<std::string> nodeList;
		bool left;
	};

	std::vector<TreeNode> nodes = { { (int16_t) 0xFFFF, 0, 0, "" } };
	std::deque<QueueEntry> queue = { { 0, -1, fileNames, std::vector<std::string>(), false } };

	while (!queue.empty()) {
		QueueEntry entry = queue.front();
		queue.pop_front();
		TreeNode &parent = nodes[entry.parentNode];

		std::vector <std::string> nodeless;
		std::vector <std::string> withNode;

		for (auto file : entry.list) {
			if (std::find(entry.nodeList.begin(), entry.nodeList.end(), file) == entry.nodeList.end())
				nodeless.push_back(file);
			else
				withNode.push_back(file);
		}

		if (nodeless.size() == 0) {
			auto firstFile = entry.list[0];
			auto itr = std::find_if(nodes.begin(), nodes.end(), [firstFile](const TreeNode &node) { return node.name == firstFile; });
			ptrdiff_t offset = std::distance(nodes.begin(), itr);

			if (entry.left)
				parent.left = (uint16_t) offset;
			else
				parent.right = (uint16_t) offset;

			continue;
		}

		TreeNode child = findFirstBitMismatch(entry.val1 + 1, nodeless, withNode);

		if (entry.left)
			parent.left = (uint16_t) nodes.size();
		else
			parent.right = (uint16_t) nodes.size();

		std::vector<std::string> left;
		std::vector<std::string> right;

		for (auto file : entry.list) {
			if ((file[child.compareBit >> 3] >> (child.compareBit & 7)) & 1)
				right.push_back(file);
			else
				left.push_back(file);
		}

		std::vector<std::string> newNodeList = entry.nodeList;
		newNodeList.push_back(child.name);

		if (left.size() > 0) queue.push_front({ static_cast<uint16_t>(nodes.size()), child.compareBit, left, newNodeList, true });
		if (right.size() > 0) queue.push_front({ static_cast<uint16_t>(nodes.size()), child.compareBit, right, newNodeList, false });
		nodes.push_back(child);
	}

	return nodes;
}

CompressionResult getFileData(const boost::filesystem::path path, const bool compress) {
	doboz::Compressor comp;
	boost::filesystem::ifstream input(path, std::ios::in | std::ios::binary);
	input.seekg(0, std::ios::end);
	std::streamoff length = input.tellg();
	input.seekg(0, std::ios::beg);

	char* data = new char[length];
	input.read(data, length);

	if (!input.good())
		std::cout << "Error: something went wrong while reading " << path << std::endl;

	input.close();

	if (compress) {
		size_t destSize;
		char* outputData = new char[comp.getMaxCompressedSize(length)];
		doboz::Result res = comp.compress(data, length, outputData, comp.getMaxCompressedSize(length), destSize);
		delete data;

		if (res != doboz::RESULT_OK)
			std::cout << "Error: something went wrong while compressing, doboz error code: " << res << std::endl;

		return { (uint32_t) length, (uint32_t) destSize, outputData };
	}
	else {
		return { (uint32_t) length, (uint32_t) length, data };
	}
}

void packMDB1(const boost::filesystem::path source, const boost::filesystem::path target, const bool compress) {
	if (!boost::filesystem::is_directory(source)) {
		std::cout << "Error: source path is not a directory." << std::endl;
		return;
	}

	if (!boost::filesystem::exists(target))
		boost::filesystem::create_directories(target.parent_path());
	else if (!boost::filesystem::is_regular_file(target)) {
		std::cout << "Error: target path already exists and is not a file." << std::endl;
		return;
	}

	std::cout << "Generating file tree..." << std::endl;
	std::vector<boost::filesystem::path> files;
	std::vector<TreeNode> nodes = generateTree(source);

	for (auto i : boost::filesystem::recursive_directory_iterator(source))
		if (boost::filesystem::is_regular_file(i))
			files.push_back(i);

	std::map<std::string, std::future<CompressionResult>> futureMap;

	std::cout << "Start compressing files..." << std::endl;
	// start compressing files
	// this may have to be replaced with a thread pool in the future, since std::async may not use one in all cases
	for (auto file : files)
		futureMap[file.string()] = std::async(getFileData, file, compress);

	std::vector<FileEntry> header1(files.size() + 1);
	std::vector<FileNameEntry> header2(files.size() + 1);
	std::vector<DataEntry> header3;

	boost::filesystem::ofstream output(target, std::ios::out | std::ios::binary);

	size_t dataStart = 0x14 + (1 + files.size()) * 0x08 + (1 + files.size()) * 0x40 + (files.size()) * 0x0C;
	MDB1Header header = { MDB1_MAGIC_VALUE, (uint16_t) (files.size() + 1), (uint16_t) (files.size() + 1), (uint32_t) files.size(), (uint32_t) dataStart };

	FileEntry root = { (int16_t) 0xFFFF, 0xFFFF, 0, 1 };
	header1[0] = root;
	header2[0] = FileNameEntry();

	uint32_t fileCount = 0;
	uint32_t numFiles = files.size();
	std::cout << "Start writing " << numFiles << " files..." << std::endl;

	uint32_t offset = 0;
	for (auto file : files) {
		if (++fileCount % 200 == 0)
			std::cout << "File " << fileCount << " of " << numFiles << std::endl;

		// fill in name
		FileNameEntry entry2;

		std::string ext = file.extension().string().substr(1, 5);
		if (ext.length() == 3)
			ext = ext.append(" ");

		// strncpy weirdness intended
		strncpy(entry2.extension, ext.c_str(), 4);
		strncpy(entry2.name, boost::filesystem::relative(file, source).replace_extension("").string().c_str(), 0x3C);

		// find corresponding node, create table entry
		auto found = std::find_if(nodes.begin(), nodes.end(), [entry2](const TreeNode &node) { return node.name == entry2.extension; });
		if (found == nodes.end())
			std::cout << "Fatal error: Couldn't find node for " << entry2.extension << std::endl;

		TreeNode treeNode = *found;
		ptrdiff_t nodeId = std::distance(nodes.begin(), found);

		// get data and write it
		CompressionResult data = futureMap[file.string()].get();

		output.seekp(dataStart + offset);
		output.write(data.data, data.size);

		futureMap.erase(file.string());
		delete data.data;

		// store table entries
		header1[nodeId] = { treeNode.compareBit, (uint16_t) header3.size(), treeNode.left, treeNode.right };
		header2[nodeId] = entry2;
		header3.push_back({ offset, data.originalSize, data.size });
		offset += data.size;
	}

	std::cout << "Writing and compressing files complete." << std::endl;

	// write file table and header
	output.seekp(0x14);

	for (auto entry : header1)
		output.write(reinterpret_cast<char*>(&entry), 0x08);
	for (auto entry : header2)
		output.write(reinterpret_cast<char*>(&entry), 0x40);
	for (auto entry : header3)
		output.write(reinterpret_cast<char*>(&entry), 0x0C);

	output.seekp(0x00);
	output.seekp(0, std::ios::end);
	std::streamoff length = output.tellp();
	output.seekp(0, std::ios::beg);

	header.totalSize = (uint32_t) length;
	output.write(reinterpret_cast<char*>(&header), 0x14);

	if (!output.good())
		std::cout << "Error: something went wrong with the output stream." << std::endl;

	output.close();
}

void cryptFile(const boost::filesystem::path source, const boost::filesystem::path target) {
	if (boost::filesystem::equivalent(source, target)) {
		std::cout << "Error: input and output path must be different!" << std::endl;
		return;
	}
	if (!boost::filesystem::is_regular_file(source)) {
		std::cout << "Error: input path is not a file." << std::endl;
		return;
	}
	if(!boost::filesystem::exists(target))
		boost::filesystem::create_directories(target.parent_path());
	else if (!boost::filesystem::is_regular_file(target)) {
		std::cout << "Error: target path already exists and is not a file." << std::endl;
		return;
	}
	
	boost::filesystem::ifstream input(source, std::ios::binary | std::ios::in);
	boost::filesystem::ofstream output(target, std::ios::binary | std::ios::out);
	std::istreambuf_iterator<char> inputItr(input);
	std::ostreambuf_iterator<char> outputItr(output);

	int key1Offset = 0;
	int key2Offset = 0;

	char* inArr = new char[0x2000];
	char* outArr = new char[0x2000];

	while (!input.eof()) {
		input.read(inArr, 0x2000);
		std::streamsize count = input.gcount();

		for (int i = 0; i < count; i++) {
			outArr[i] = inArr[i] ^ CRYPT_KEY_1[key1Offset] ^ CRYPT_KEY_2[key2Offset];
			key1Offset = (key1Offset + 1) % 997;
			key2Offset = (key2Offset + 1) % 991;
		}

		output.write(outArr, count);
	}

	delete inArr;
	delete outArr;

	input.close();
	output.close();
}